initSidebarItems({"enum":[["Call","Contains one variant per dispatchable that can be called by an extrinsic."],["Error","Custom dispatch errors of this pallet."],["Event","The event emitted by this pallet."]],"struct":[["GenesisConfig","Can be used to configure the genesis state of this pallet."],["Pallet","The pallet implementing the on-chain logic."],["_GeneratedPrefixForStorageCurrentUnbondIndex",""],["_GeneratedPrefixForStorageExchangeRate",""],["_GeneratedPrefixForStorageLastSettlementTime",""],["_GeneratedPrefixForStorageMarketCap",""],["_GeneratedPrefixForStorageMatchingPool",""],["_GeneratedPrefixForStoragePendingUnstake",""],["_GeneratedPrefixForStorageReserveFactor",""],["_GeneratedPrefixForStorageTotalReserves",""],["_GeneratedPrefixForStorageXcmRequests",""]],"trait":[["Config","Configuration trait of this pallet."]],"type":[["AccountIdOf",""],["AssetIdOf",""],["BalanceOf",""],["CurrentUnbondIndex","Current unbond index Users can come to claim their unbonded staking assets back once this value arrived at certain height decided by `BondingDuration` and `EraLength`"],["ExchangeRate","The exchange rate between relaychain native asset and the voucher."],["LastSettlementTime","Last settlement time Settlement must be executed once and only once in every relaychain era"],["MarketCap","Liquid currencyâ€™s market cap"],["MatchingPool","Store total stake amount and unstake amount in each era, And will update when stake/unstake occurred."],["Module","Type alias to `Pallet`, to be used by `construct_runtime`."],["PendingUnstake","Pending unstake requests"],["ReserveFactor","Fraction of reward currently set aside for reserves."],["TotalReserves",""],["UnbondIndex",""],["XcmRequests","Flying & failed xcm requests"]]});